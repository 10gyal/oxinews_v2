"""
Utility functions for database operations.
"""
from supabase import create_client
import config
import logging

# Initialize Supabase client
supabase = create_client(config.SUPABASE_URL, config.SUPABASE_ANON_KEY)

def get_pipeline_config(pipeline_id, delivery_count=None):
    """
    Get pipeline configuration from Supabase.
    
    Args:
        pipeline_id (str): The ID of the pipeline
        delivery_count (int, optional): Filter by delivery count
        
    Returns:
        dict: Pipeline configuration or None if not found
    """
    try:
        query = supabase.table('pipeline_configs').select('*').eq('pipeline_id', pipeline_id)
        
        if delivery_count is not None:
            query = query.eq('delivery_count', delivery_count)
            
        response = query.execute()
        
        if response.data and len(response.data) > 0:
            return response.data[0]
        return None
    except Exception as e:
        logging.error(f"Error getting pipeline config: {str(e)}")
        return None

def get_scheduled_pipelines(lead_time_minutes=30):
    """
    Get pipelines that are scheduled to run soon.
    
    Args:
        lead_time_minutes (int): Minutes before delivery time to run the pipeline
        
    Returns:
        list: List of pipeline configurations
    """
    try:
        # Get all active pipelines
        response = supabase.table('pipeline_configs').select('*').eq('is_active', True).execute()
        
        if not response.data:
            return []
            
        return response.data
    except Exception as e:
        logging.error(f"Error getting scheduled pipelines: {str(e)}")
        return []

def update_pipeline_delivery_stats(pipeline_id, delivery_count, last_delivered):
    """
    Update pipeline delivery statistics.
    
    Args:
        pipeline_id (str): The ID of the pipeline
        delivery_count (int): New delivery count
        last_delivered (str): ISO format datetime of last delivery
        
    Returns:
        bool: True if successful, False otherwise
    """
    try:
        supabase.table('pipeline_configs').update({
            'delivery_count': delivery_count,
            'last_delivered': last_delivered,
            'last_delivered_time': last_delivered
        }).eq('pipeline_id', pipeline_id).execute()
        return True
    except Exception as e:
        logging.error(f"Error updating pipeline delivery stats: {str(e)}")
        return False

def get_latest_issue_number(pipeline_id):
    """
    Get the latest issue number for a pipeline.
    
    Args:
        pipeline_id (str): The ID of the pipeline
        
    Returns:
        int: Latest issue number or 0 if none found
    """
    try:
        response = supabase.table('pipeline_reads').select('issue').eq('pipeline_id', pipeline_id).order('issue', desc=True).limit(1).execute()
        
        if response.data and len(response.data) > 0:
            return response.data[0]['issue']
        return 0
    except Exception as e:
        logging.error(f"Error getting latest issue number: {str(e)}")
        return 0

def save_pipeline_content(pipeline_id, pipeline_name, title, content, user_id):
    """
    Save pipeline content to the database.
    
    Args:
        pipeline_id (str): The ID of the pipeline
        pipeline_name (str): The name of the pipeline
        title (str): The title of the content
        content (list): The content generated by the pipeline
        user_id (str): The ID of the user
        
    Returns:
        bool: True if successful, False otherwise
    """
    try:
        # Get the latest issue number and increment by 1
        issue = get_latest_issue_number(pipeline_id) + 1
        
        # Insert the new content
        supabase.table('pipeline_reads').insert({
            'pipeline_id': pipeline_id,
            'pipeline_name': pipeline_name,
            'title': title,
            'content': content,
            'user_id': user_id,
            'issue': issue
        }).execute()
        
        return True
    except Exception as e:
        logging.error(f"Error saving pipeline content: {str(e)}")
        return False
